class PluginApi:
    # A string with the name of this plugin
    PLUGIN_NAME = None
    # A string with the description of this plugin
    PLUGIN_DESCRIPTION = None
    # A list of PluginCommands handled by this plugin
    COMMANDS = []
    HELP_COMMAND = "help"

    def __init__(self, name, **kwargs):
        """
        Any arguments added in the Kilroy config file will be passed on startup.
        :param name: REQUIRED: The name of this plugin
        :param kwargs:
        """
        if name != self.PLUGIN_NAME:
            raise AttributeError("Attempting to load an invalid plugin")
        self._command_dict = {}
        for c in self.COMMANDS:
            self._command_dict[c.COMMAND_NAME] = c

    def is_handled(self, message_str):
        """
        Determines if the message string is handled by this plugin
        :param message_str: The message to be checked with the kilry prefix stripped
        :type message_str: str
        :return: True if handled, else false
        """
        if message_str.split(" ")[0] == self.PLUGIN_NAME:
            return True
        return False

    async def print_help(self, message, connection):
        """
        Prints the help message generated by this connection
        :param message: The message that generated this request
        :param connection: The connection that generated this message
        """
        s = ""
        s += "{} -- {}\n\n".format(self.PLUGIN_NAME, self.PLUGIN_DESCRIPTION)
        s += "Plugin Commands:\n"
        for c in self._command_dict.values():
            s += "{} -- {}\n".format(c.COMMAND_NAME, c.COMMAND_DESCRIPTION)
        s += "\nType {} {} COMMAND_NAME for more details.".format(str(message).split(" ")[0], self.HELP_COMMAND)
        await message.get_channel().send_text(connection, s)

    async def message_handler(self, message, connection, db_connection):
        """
        Handles messages passed to this module.  By default, it will parse/call PluginCommands
        attached to this module.
        :param message: The message to be parsed, including the kilroy prefix
        :type message: Message
        :param connection: The connection that generated this message.
        :type connection: Connection
        :param db_connection:
        :type db_connection: kilroy.SqlConnection
        """
        args = str(message).split(" ")[1:]
        command = args[0]
        if command == self.HELP_COMMAND:
            if len(args) > 2 and args[1] in self._command_dict:
                await self._command_dict[command].print_help(message, connection)
            else:
                await self.print_help(message, connection)
        elif command in self._command_dict:
            await self._command_dict[command].execute_command(message, connection, db_connection)


class PluginCommand:
    # The name of this command
    COMMAND_NAME = None
    # A short description of this command
    COMMAND_DESCRIPTION = None
    # A description of the arguments passed to this command, in order
    COMMAND_ARGS = {
        # "test_arg": "string - a test argument"
    }

    @classmethod
    def parse_args(cls, message):
        raw_args = str(message).split(" ")[1:]
        args = []
        for a in raw_args:
            if a != '':
                args += [a]
        return args

    @classmethod
    async def execute_command(cls, message, connection, db_connection):
        raise NotImplementedError()


class TestCommand:
    COMMAND_NAME = "test_command"
    IS_CALLED = False

    @classmethod
    async def execute_command(cls, message, connection, db_connection):
        cls.IS_CALLED = True


class HelloKilroy(PluginApi):
    """
    An example plugin for Kilroy
    """
    PLUGIN_NAME = "hello_kilroy"

    def __init__(self, name, **kwargs):
        super().__init__(name, **kwargs)

    async def message_handler(self, message, connection, db_connection):
        pass


class TestPlugin(PluginApi):
    PLUGIN_NAME = "test_plugin"
    COMMANDS = [
        TestCommand
    ]

    def __init__(self, name):
        super().__init__(name)
        self.is_called = False

    async def message_handler(self, message, connection, db_connection):
        self.is_called = True
        await super().message_handler(message, connection, db_connection)
