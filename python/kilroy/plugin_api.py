class PluginApi:
    # A string with the name of this plugin
    PLUGIN_NAME = None
    # A string with the description of this plugin
    PLUGIN_DESCRIPTION = None
    # A list of PluginCommands handled by this plugin
    COMMANDS = []
    HELP_COMMAND = "help"

    def __init__(self, name, **kwargs):
        """
        Any arguments added in the Kilroy config file will be passed on startup.
        :param name: REQUIRED: The name of this plugin
        :param kwargs:
        """
        if name != self.PLUGIN_NAME:
            raise AttributeError("Attempting to load an invalid plugin")
        self._command_dict = {}
        for c in self.COMMANDS:
            self._command_dict[c.COMMAND_NAME] = c

    def is_handled(self, message):
        """
        Determines if the message string is handled by this plugin
        :param message: The message to be checked
        :type message: kilroy.PluginMessage
        :return: True if handled, else false
        """
        if message.plugin_prefix.endswith(self.PLUGIN_NAME):
            return True
        return False

    async def print_help(self, message):
        """
        Prints the help message generated by this connection
        :param message: The message that generated this request
        :type message: kilroy.PluginMessage
        """
        s = ""
        s += "{} -- {}\n\n".format(self.PLUGIN_NAME, self.PLUGIN_DESCRIPTION)
        s += "Plugin Commands:\n"
        for c in self._command_dict.values():
            s += "{} -- {}\n".format(c.COMMAND_NAME, c.COMMAND_DESCRIPTION)
        s += "\nType {} {} COMMAND_NAME for more details.".format(message.plugin_prefix, self.HELP_COMMAND)
        await message.send_reply(s)

    async def message_handler(self, message):
        """
        Handles messages passed to this module.  By default, it will parse/call PluginCommands
        attached to this module.
        :param message: the message to be handled
        :type message: kilroy.PluginMessage
        """
        args = message.plugin_command
        command = args[0]
        if command == self.HELP_COMMAND:
            if len(args) >= 2 and args[1] in self._command_dict:
                await self._command_dict[args[1]].print_help(message)
            else:
                await self.print_help(message)
        elif command in self._command_dict:
            await self._command_dict[command].execute_command(message)


class PluginCommand:
    # The name of this command
    COMMAND_NAME = None
    # A short description of this command
    COMMAND_DESCRIPTION = None
    # A description of the arguments passed to this command, in order
    COMMAND_ARGS = [
        # ("test_arg", "string - a test argument")
    ]

    @classmethod
    async def print_help(cls, message):
        s = ""
        s += "{} -- {}\n\n".format(cls.COMMAND_NAME, cls.COMMAND_DESCRIPTION)
        u = ""
        if len(cls.COMMAND_ARGS) > 0:
            s += "Arguments:\n"
            for c in cls.COMMAND_ARGS:
                s += "{} -- {}\n".format(c[0], c[1])
                u += "{} ".format(c[0].upper())
        s += "\nUsage: {} {} ".format(message.plugin_prefix, cls.COMMAND_NAME)
        s += u
        await message.send_reply(s)

    @classmethod
    async def execute_command(cls, message):
        raise NotImplementedError()


class TestCommand:
    COMMAND_NAME = "test_command"
    IS_CALLED = False

    @classmethod
    async def execute_command(cls, message):
        cls.IS_CALLED = True


class HelloKilroy(PluginApi):
    """
    An example plugin for Kilroy
    """
    PLUGIN_NAME = "hello_kilroy"

    def __init__(self, name, **kwargs):
        super().__init__(name, **kwargs)

    async def message_handler(self, message):
        pass


class TestPlugin(PluginApi):
    PLUGIN_NAME = "test_plugin"
    COMMANDS = [
        TestCommand
    ]

    def __init__(self, name):
        super().__init__(name)
        self.is_called = False

    async def message_handler(self, message):
        self.is_called = True
        await super().message_handler(message)
